Výsledky
========

IncrementValueInDictionary_KeyNotFound-report.md

| Method                | Mean        | Error      | StdDev     |
|---------------------- |------------:|-----------:|-----------:|
| IncrementWordCount_V1 | 3,873.22 ns | 174.455 ns | 489.189 ns |
| IncrementWordCount_V2 |    49.41 ns |   3.346 ns |   9.437 ns |
| IncrementWordCount_V3 |    52.33 ns |   3.007 ns |   8.579 ns |


IncrementValueInDictionary_KeyFound-report.md

| Method                | Mean     | Error    | StdDev   |
|---------------------- |---------:|---------:|---------:|
| IncrementWordCount_V1 | 36.49 ns | 0.164 ns | 0.145 ns |
| IncrementWordCount_V2 | 46.66 ns | 0.490 ns | 0.434 ns |
| IncrementWordCount_V3 | 33.88 ns | 0.526 ns | 0.466 ns |


Interpretace výsledků
=====================

1) WordNotFound

	Výsledky benchmarku tohoto případu mě nepřekvapily. Pouze potvrdily, že výjimky jsou velmi pomalé.
	Oproti ostatním dvěma variantám zhruba 75x pomalejší. Co se týče V2 a V3, jsou srovnatelné.

2) WordFound
	
	Tyto výsledky mě zprvu překvapily. V2 vyšla o cca 40% pomalejší než ostatní dvě varianty. Po zamyšlení
	mi to ale dává smysl. Ve V2 totiž vždy provádíme volání Contains na slovník a to i v případě, že se slovo
	ve slovníku nachází.


Shrnutí
=======

Z výsledků se mi potvrdilo, že bych rozhodně neměl používat try/catch blok. Zbývá se rozhodnout mezi V2 pomocí
Contains a V3 pomocí TryGetValue. V3 je s V2 srovnatelné v případě přidávání nového klíče a v případě
přičítání k výskytům existujícího klíče je znatelně rychlejší. Zvolím proto pro implementaci zaznamenávání
frekvence slov pomocí slovníku variantu V3 s TryGetValue.